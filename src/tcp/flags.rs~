use std::fmt::Debug;

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum Flag {
    SYN = 2,
    PSH = 8,
    FIN = 1,
    RST = 4,
    URG = 32,
    ACK = 16,
}

pub enum FlagError {
    InvalidFlagChar,
}

impl TryInto<Flag> for char {
    type Error = FlagError;

    fn try_into(self) -> Result<Flag, FlagError> {
        match self {
            'S' => Ok(Flag::SYN),
            'P' => Ok(Flag::PSH),
            'F' => Ok(Flag::FIN),
            'R' => Ok(Flag::RST),
            'U' => Ok(Flag::URG),
            '.' => Ok(Flag::ACK),
            _ => Err(FlagError::InvalidFlagChar),
        }
    }
}

impl Into<char> for Flag {
    fn into(self) -> char {
        match self {
            Flag::SYN => 'S',
            Flag::PSH => 'P',
            Flag::FIN => 'F',
            Flag::RST => 'R',
            Flag::URG => 'U',
            Flag::ACK => '.',
        }
    }
}

#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Flags(u8); // it's u6 irl tho

impl Flags {
    pub fn new() -> Self {
        Self(0)
    }

    pub fn set(&mut self, flag: Flag) {
        self.0 |= flag as u8;
    }

    pub fn unset(&mut self, flag: Flag) {
        self.0 &= !(flag as u8) & 0b00111111; // Disable first two bits, otherwise Eq might break
    }

    pub fn is_set(&self, flag: Flag) -> bool {
        (self.0 & (flag as u8)) != 0
    }
}

impl Debug for Flags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for i in 6..=0 {
            if (self >> i) & 1 != 0 {
                (f, ((1 << i) as Flag).into())
            }
        }
        Ok(())
    }
}
